Како работи Push-Relabel алгоритмот?

-Овој алгоритам е наменет за наоѓање на максимален проток од извор до сливник. Тука може да се дефинира поим висина на теме.
-Карактеристични функции во овој алгоритам се push, relabel и discharge.
-Проток се пушта од теме со поголема висина кон теме со помала.
-Во првиот чекор, ќе поставиме висина на сите темиња да се 0, освен висината на првото 
теме, која ќе биде n. Максималниот проток кој може да се пушти од првото теме ќе биде бесконечно, 
за да можеме да пуштиме проток до соседите. Потоа, пуштаме максимален проток до соседите на изворот, 
односно колку што е капацетот на ребрата формирани од изворот и соседните темиња. Ова го правиме со функцијата push, 
во која освен тоа што правиме остаточна мрежа, ги обновуваме останатиот проток до темето (ostatok) како и ја обновуваме 
листата на активни темиња, доколку некое теме стане активно (т.е. добие проток низ него). Графот ќе го обновуваме се 
додека имаме активни темиња. Ќе земеме активно теме, ќе го отстраниме од листата, па потоа ќе го испразниме, односно
ќе го направиме неактивно (применување на функцијата discharge). Оваа функција работи се додека остатокот на проток 
во темето е поголем од 0. Тука ќе дефинираме и низа checkpoint која ќе води сметка на тоа до кој сосед сме стингале, 
со цел да не мора од почеток сите соседи да се прегледуваат без потреба. Проверуваме дали условите на алгоритмот се 
задоволени за секој сосед, и ако се, тогаш ќе искористиме push. Ако не се, преминуваме на друг сосед, односно инкрементација 
на checkpoint во индекс u. Koga checkpoint ќе биде еднаков на бројот на темиња, односно ќе стигнеме до крајното теме, ќе 
примениме relabel и го ресетираме checkpoint на индекс u. Relabel работи на тој начин што висината на темето го 
инкрементира за 1 од најмалата висина од сите соседи. Ова се прави бидејќи проток се пушта од теме со поголема висина 
кон теме со помала висина. По сите овие чекори, само пресметуваме max flow со соодветната функција.
-Пресметување на временска сложеност: Нека V е бројот на темиња. Максимална висина на теме е 2|V|-1, значи имаме O(V^2) 
relabel операции. Исто така има O(V*E) сатурирачки 'push-ови' и O(V^2*E) не-сатурирачки. Вкупната сложеност е O(V^2*E)

Споредба со Edmonds-Karp
-Push-Relabel ги поместува протоците по висина на темињата додека ЕК наоѓа аугментирачки патеки од извор до сливник
-Push-Relabel може да биде многу побрз на погусти графови
-EK е полесен за имплементација
Edmonds-Karp работи на принцип на аугментирачки патеки кои ги наоѓа со BFS и пушта проток по истите. Push-Relabel е по ефикасен, 
со временска сложеност O(V2E) споредено со Edmonds-Karp O(VE2). Исто како и во споредбата со Dinic, Push-Relabel е поефикасен за 
повеќето графови а особено за густите графови. Edmonds-Karp се користи најчесто кај ретки грфови, каде што се бара поедноставен и 
поинтуитивен алгоритам.


Споредба со Dinic
-Dinic гради level графови и користи BFS и DFS
-Push-Relabel работи со висини(без BFS и DFS)
-Dinic е подобар на поредки графови додека Push-Relabel на погусти
Идејата позади Dinic е да се користат level-graphs, односно нивоа на графовите, и тие да се ажурираат секогаш кога ќе искористиме BFS.
Проток се пушта од ниво level[u] кон level[v] = level[u] + 1, што е сличен концепт (иако со големи разлики) како висините во 
Push-Relabel, со таа разлика што висините не се наоѓаат со BFS ни со DFS туку со relabel функцијата. Dinic има временска сложеност 
O(V2E), додека Push-Relabel може да има О(V3) (FIFO), O(V2√E) (Highest Level PreFlow). 
Dinic е поефикасен за поретки графови, додека Push-Relabel за погусти графови, поради правилата за избор каде ќе пуштиме проток.
